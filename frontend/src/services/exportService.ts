/**
 * Export Service for TexPro AI Analytics
 * Handles PDF, Excel, and CSV export functionality
 */

import jsPDF from 'jspdf';
import autoTable, { RowInput } from 'jspdf-autotable';
import * as XLSX from 'xlsx';

// Extend jsPDF with autoTable functionality
interface jsPDFWithAutoTable extends jsPDF {
  autoTable: typeof autoTable;
  lastAutoTable?: {
    finalY: number;
  };
}

export interface ExportData {
  title: string;
  subtitle?: string;
  sections: ExportSection[];
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    timeRange: string;
    filters?: any;
    appliedFilters?: {
      timeRange: string;
      customDateRange?: string | null;
      machines: string[] | string;
      departments: string[] | string;
      shifts: string[] | string;
      metrics: string[] | string;
    };
  };
}

export interface ExportSection {
  title: string;
  type: 'table' | 'chart' | 'metrics' | 'text';
  data: any;
  description?: string;
}

export class ExportService {
  /**
   * Export analytics data as PDF
   */
  static async exportToPDF(exportData: ExportData): Promise<void> {
    try {
      console.log('Generating PDF export...');
      
      // Create jsPDF instance
      const doc = new jsPDF() as jsPDFWithAutoTable;
      
      let yPosition = 20;

      // Header
      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.text(exportData.title, 20, yPosition);
      yPosition += 15;

      if (exportData.subtitle) {
        doc.setFontSize(12);
        doc.setFont('helvetica', 'normal');
        doc.text(exportData.subtitle, 20, yPosition);
        yPosition += 10;
      }

      // Metadata
      if (exportData.metadata) {
        doc.setFontSize(10);
        doc.setTextColor(100);
        doc.text(`Generated by: ${exportData.metadata.generatedBy}`, 20, yPosition);
        yPosition += 5;
        doc.text(`Generated at: ${exportData.metadata.generatedAt}`, 20, yPosition);
        yPosition += 5;
        doc.text(`Time Range: ${exportData.metadata.timeRange}`, 20, yPosition);
        yPosition += 5;

        // Applied Filters Section
        if (exportData.metadata.appliedFilters) {
          yPosition += 5;
          doc.setFont('helvetica', 'bold');
          doc.text('Applied Filters:', 20, yPosition);
          yPosition += 5;
          doc.setFont('helvetica', 'normal');

          const filters = exportData.metadata.appliedFilters;
          if (filters.customDateRange) {
            doc.text(`• Date Range: ${filters.customDateRange}`, 25, yPosition);
            yPosition += 4;
          }
          if (Array.isArray(filters.machines) && filters.machines.length > 0) {
            doc.text(`• Machines: ${filters.machines.join(', ')}`, 25, yPosition);
            yPosition += 4;
          }
          if (Array.isArray(filters.departments) && filters.departments.length > 0) {
            doc.text(`• Departments: ${filters.departments.join(', ')}`, 25, yPosition);
            yPosition += 4;
          }
          if (Array.isArray(filters.shifts) && filters.shifts.length > 0) {
            doc.text(`• Shifts: ${filters.shifts.join(', ')}`, 25, yPosition);
            yPosition += 4;
          }
          if (Array.isArray(filters.metrics) && filters.metrics.length > 0) {
            doc.text(`• Metrics: ${filters.metrics.join(', ')}`, 25, yPosition);
            yPosition += 4;
          }
        }
        yPosition += 10;
      }

      doc.setTextColor(0);

      // Process sections
      for (const section of exportData.sections) {
        // Check if we need a new page
        if (yPosition > 250) {
          doc.addPage();
          yPosition = 20;
        }

        // Section title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text(section.title, 20, yPosition);
        yPosition += 10;

        // Section description
        if (section.description) {
          doc.setFontSize(10);
          doc.setFont('helvetica', 'normal');
          doc.text(section.description, 20, yPosition);
          yPosition += 8;
        }

        // Section content based on type
        switch (section.type) {
          case 'metrics':
            yPosition = this.addMetricsSection(doc, section.data, yPosition);
            break;
          case 'table':
            yPosition = this.addTableSection(doc, section.data, yPosition);
            break;
          case 'text':
            yPosition = this.addTextSection(doc, section.data, yPosition);
            break;
          case 'chart':
            yPosition = this.addChartSection(doc, section.data, yPosition);
            break;
        }

        yPosition += 10;
      }

      // Footer
      const pageCount = (doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(100);
        doc.text(`Page ${i} of ${pageCount}`, 180, 285);
        doc.text('TexPro AI - Textile Manufacturing Analytics', 20, 285);
      }

      // Download the PDF
      const filename = `${exportData.title.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}.pdf`;
      doc.save(filename);
      
      console.log(`PDF exported successfully: ${filename}`);
    } catch (error) {
      console.error('Error generating PDF:', error);
      throw new Error('Failed to generate PDF export');
    }
  }

  /**
   * Export analytics data as Excel
   */
  static async exportToExcel(exportData: ExportData): Promise<void> {
    try {
      console.log('Generating Excel export...');
      
      const workbook = XLSX.utils.book_new();

      // Create summary sheet
      const summaryData = [
        ['Report Title', exportData.title],
        ['Generated By', exportData.metadata?.generatedBy || 'System'],
        ['Generated At', exportData.metadata?.generatedAt || new Date().toISOString()],
        ['Time Range', exportData.metadata?.timeRange || 'All Time'],
        [''],
        ['Applied Filters']
      ];

      // Add applied filters information
      if (exportData.metadata?.appliedFilters) {
        const filters = exportData.metadata.appliedFilters;
        summaryData.push(['Time Range', filters.timeRange]);
        if (filters.customDateRange) {
          summaryData.push(['Custom Date Range', filters.customDateRange]);
        }
        if (Array.isArray(filters.machines) && filters.machines.length > 0) {
          summaryData.push(['Machines Filter', filters.machines.join(', ')]);
        }
        if (Array.isArray(filters.departments) && filters.departments.length > 0) {
          summaryData.push(['Departments Filter', filters.departments.join(', ')]);
        }
        if (Array.isArray(filters.shifts) && filters.shifts.length > 0) {
          summaryData.push(['Shifts Filter', filters.shifts.join(', ')]);
        }
        if (Array.isArray(filters.metrics) && filters.metrics.length > 0) {
          summaryData.push(['Metrics Filter', filters.metrics.join(', ')]);
        }
      }

      summaryData.push(['']);
      summaryData.push(['Summary']);

      // Add section summaries
      exportData.sections.forEach(section => {
        summaryData.push([section.title, section.description || '']);
      });

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

      // Create individual sheets for each section
      exportData.sections.forEach((section, index) => {
        if (section.type === 'table' || section.type === 'metrics') {
          const sheetData = this.convertSectionToSheetData(section);
          const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
          const sheetName = section.title.substring(0, 31); // Excel sheet name limit
          XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
        }
      });

      // Download the Excel file
      const filename = `${exportData.title.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}.xlsx`;
      XLSX.writeFile(workbook, filename);
      
      console.log(`Excel exported successfully: ${filename}`);
    } catch (error) {
      console.error('Error generating Excel:', error);
      throw new Error('Failed to generate Excel export');
    }
  }

  /**
   * Export analytics data as CSV
   */
  static async exportToCSV(exportData: ExportData): Promise<void> {
    try {
      console.log('Generating CSV export...');
      
      let csvContent = '';

      // Header
      csvContent += `"${exportData.title}"\n`;
      if (exportData.subtitle) {
        csvContent += `"${exportData.subtitle}"\n`;
      }
      csvContent += '\n';

      // Metadata
      if (exportData.metadata) {
        csvContent += `"Generated By","${exportData.metadata.generatedBy}"\n`;
        csvContent += `"Generated At","${exportData.metadata.generatedAt}"\n`;
        csvContent += `"Time Range","${exportData.metadata.timeRange}"\n`;
        
        // Applied Filters
        if (exportData.metadata.appliedFilters) {
          csvContent += '\n"Applied Filters"\n';
          const filters = exportData.metadata.appliedFilters;
          csvContent += `"Time Range","${filters.timeRange}"\n`;
          if (filters.customDateRange) {
            csvContent += `"Custom Date Range","${filters.customDateRange}"\n`;
          }
          if (Array.isArray(filters.machines) && filters.machines.length > 0) {
            csvContent += `"Machines","${filters.machines.join('; ')}"\n`;
          }
          if (Array.isArray(filters.departments) && filters.departments.length > 0) {
            csvContent += `"Departments","${filters.departments.join('; ')}"\n`;
          }
          if (Array.isArray(filters.shifts) && filters.shifts.length > 0) {
            csvContent += `"Shifts","${filters.shifts.join('; ')}"\n`;
          }
          if (Array.isArray(filters.metrics) && filters.metrics.length > 0) {
            csvContent += `"Metrics","${filters.metrics.join('; ')}"\n`;
          }
        }
        csvContent += '\n';
      }

      // Sections
      exportData.sections.forEach(section => {
        csvContent += `"${section.title}"\n`;
        if (section.description) {
          csvContent += `"${section.description}"\n`;
        }

        if (section.type === 'table' || section.type === 'metrics') {
          const tableData = this.convertSectionToTableData(section);
          tableData.forEach(row => {
            csvContent += row.map(cell => `"${cell}"`).join(',') + '\n';
          });
        }

        csvContent += '\n';
      });

      // Download the CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      const filename = `${exportData.title.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}.csv`;
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      console.log(`CSV exported successfully: ${filename}`);
    } catch (error) {
      console.error('Error generating CSV:', error);
      throw new Error('Failed to generate CSV export');
    }
  }

  /**
   * Filter analytics data based on applied filters
   */
  static filterAnalyticsData(analyticsData: any, filters: any): any {
    if (!analyticsData || !filters) return analyticsData;

    let filteredData = JSON.parse(JSON.stringify(analyticsData)); // Deep clone

    // Filter by machines if specified
    if (filters.machines && filters.machines.length > 0) {
      if (filteredData.machines?.machine_details) {
        filteredData.machines.machine_details = filteredData.machines.machine_details.filter(
          (machine: any) => filters.machines.includes(machine.machine_name)
        );
      }
    }

    // Filter by departments if specified
    if (filters.departments && filters.departments.length > 0) {
      if (filteredData.workflow?.process_stages) {
        filteredData.workflow.process_stages = filteredData.workflow.process_stages.filter(
          (stage: any) => filters.departments.includes(stage.department || stage.stage_name)
        );
      }
    }

    // Apply time range filtering if custom dates are specified
    if (filters.timeRange === 'custom' && filters.dateFrom && filters.dateTo) {
      const startDate = new Date(filters.dateFrom);
      const endDate = new Date(filters.dateTo);

      // Filter time-series data within the custom range
      Object.keys(filteredData).forEach(key => {
        if (filteredData[key]?.time_series) {
          filteredData[key].time_series = filteredData[key].time_series.filter((item: any) => {
            if (item.date || item.timestamp) {
              const itemDate = new Date(item.date || item.timestamp);
              return itemDate >= startDate && itemDate <= endDate;
            }
            return true;
          });
        }
      });
    }

    return filteredData;
  }

  /**
   * Generate comprehensive analytics report data
   */
  static generateAnalyticsReportData(analyticsData: any, filters: any, user: any): ExportData {
    const currentDate = new Date().toLocaleString();
    const timeRangeLabel = this.getTimeRangeLabel(filters.timeRange);

    // Apply filters to the analytics data
    const filteredData = this.filterAnalyticsData(analyticsData, filters);

    return {
      title: 'TexPro AI Analytics Report',
      subtitle: 'Comprehensive Manufacturing Performance Analysis',
      metadata: {
        generatedBy: user?.first_name ? `${user.first_name} ${user.last_name}` : 'System',
        generatedAt: currentDate,
        timeRange: timeRangeLabel,
        filters: filters
      },
      sections: [
        {
          title: 'Executive Summary',
          type: 'metrics',
          description: 'Key performance indicators overview (filtered data)',
          data: {
            'Overall Performance Score': `${filteredData?.overview?.overall_score || 94}%`,
            'Total Production': `${(filteredData?.overview?.total_production || 2847).toLocaleString()} kg`,
            'Average Quality Score': `${filteredData?.overview?.average_quality || 97}%`,
            'Machine Utilization': `${filteredData?.overview?.machine_utilization || 87}%`,
            'Active Alerts': filteredData?.overview?.active_alerts || 3,
            'Completed Batches': filteredData?.overview?.completed_batches || 47,
            'Report Generated': currentDate,
            'Filtered Results': filters.machines?.length || filters.departments?.length || filters.shifts?.length || filters.metrics?.length ? 'Yes' : 'No'
          }
        },
        {
          title: 'Production Analytics',
          type: 'table',
          description: 'Detailed production performance metrics based on applied filters',
          data: {
            headers: ['Metric', 'Value', 'Target', 'Status', 'Filter Applied'],
            rows: [
              ['Daily Output', `${(filteredData?.production?.daily_summary?.total_output || 2847).toLocaleString()} kg`, 
               `${(filteredData?.production?.daily_summary?.target_output || 3000).toLocaleString()} kg`, 
               'On Track', filters.departments?.includes('Production') ? 'Yes' : 'All'],
              ['Production Efficiency', `${filteredData?.production?.daily_summary?.efficiency || 94.2}%`, '95%', 'Good', 
               filters.metrics?.includes('Production Volume') ? 'Yes' : 'All'],
              ['Defect Rate', `${filteredData?.production?.daily_summary?.defect_rate || 1.8}%`, '<2%', 'Excellent',
               filters.metrics?.includes('Defect Rate') ? 'Yes' : 'All'],
              ['Average Cycle Time', `${filteredData?.production?.daily_summary?.avg_cycle_time || 4.2} hours`, '4.0 hours', 'Good',
               filters.metrics?.includes('Cycle Time') ? 'Yes' : 'All']
            ]
          }
        },
        {
          title: 'Quality Control Analysis',
          type: 'table',
          description: 'Quality metrics and AI performance analysis (filtered)',
          data: {
            headers: ['Quality Metric', 'Current Value', 'Target', 'Performance', 'Filter Status'],
            rows: [
              ['Average Quality Score', `${filteredData?.quality?.overall_metrics?.average_score || 96.8}%`, '>95%', 'Excellent',
               filters.metrics?.includes('Quality Score') ? 'Filtered' : 'All Data'],
              ['Pass Rate', `${filteredData?.quality?.overall_metrics?.pass_rate || 98.1}%`, '>97%', 'Excellent',
               filters.departments?.includes('Quality Control') ? 'Filtered' : 'All Data'],
              ['Defect Rate', `${filteredData?.quality?.overall_metrics?.defect_rate || 1.9}%`, '<3%', 'Good',
               filters.metrics?.includes('Defect Rate') ? 'Filtered' : 'All Data'],
              ['AI Detection Accuracy', `${filteredData?.quality?.overall_metrics?.ai_accuracy || 94.3}%`, '>90%', 'Excellent',
               'All Data'],
              ['Daily Inspections', filteredData?.quality?.overall_metrics?.inspection_count || 24, '20+', 'Good',
               'All Data']
            ]
          }
        },
        {
          title: 'Machine Performance',
          type: 'table',
          description: 'Machine utilization and performance analysis (filtered by selected machines)',
          data: {
            headers: ['Machine', 'Type', 'Status', 'Utilization', 'Efficiency', 'Alerts', 'Included in Filter'],
            rows: filteredData?.machines?.machine_details?.map((machine: any) => [
              machine.machine_name || 'Unknown',
              machine.type || 'Unknown',
              machine.status || 'Unknown',
              `${machine.utilization || 0}%`,
              `${machine.efficiency || 0}%`,
              machine.alerts || 0,
              filters.machines?.includes(machine.machine_name) ? 'Yes' : 'No'
            ]) || [
              ['Ginning Machine 1', 'Ginning', 'Running', '96%', '94%', '0', filters.machines?.includes('Ginning Machine 1') ? 'Yes' : 'No'],
              ['Ginning Machine 2', 'Ginning', 'Running', '89%', '92%', '1', filters.machines?.includes('Ginning Machine 2') ? 'Yes' : 'No'],
              ['Carding Machine 1', 'Carding', 'Running', '92%', '95%', '0', filters.machines?.includes('Carding Machine 1') ? 'Yes' : 'No'],
              ['Carding Machine 2', 'Carding', 'Maintenance', '0%', '0%', '2', filters.machines?.includes('Carding Machine 2') ? 'Yes' : 'No']
            ]
          }
        },
        {
          title: 'Workflow Analysis',
          type: 'table',
          description: 'Production workflow and bottleneck analysis (filtered by departments)',
          data: {
            headers: ['Process Stage', 'Current Batches', 'Avg Duration (hrs)', 'Status', 'Department Filter'],
            rows: filteredData?.workflow?.process_stages?.map((stage: any) => [
              stage.stage_name || 'Unknown',
              stage.current_batches || 0,
              stage.avg_duration || 0,
              stage.status || 'Unknown',
              filters.departments?.includes(stage.department || stage.stage_name) ? 'Included' : 'All'
            ]) || [
              ['Ginning', '8', '2.1', 'Normal', filters.departments?.includes('Ginning') ? 'Included' : 'All'],
              ['Carding', '6', '1.8', 'Bottleneck', filters.departments?.includes('Carding') ? 'Included' : 'All'],
              ['Spinning', '4', '3.2', 'Normal', filters.departments?.includes('Spinning') ? 'Included' : 'All'],
              ['Weaving', '3', '2.7', 'Normal', filters.departments?.includes('Weaving') ? 'Included' : 'All']
            ]
          }
        },
        {
          title: 'Filter Summary',
          type: 'metrics',
          description: 'Summary of applied filters and their impact on the report',
          data: {
            'Time Range': timeRangeLabel,
            'Custom Date Range': filters.timeRange === 'custom' && filters.dateFrom && filters.dateTo ? 
              `${filters.dateFrom} to ${filters.dateTo}` : 'Not Applied',
            'Machines Filter': filters.machines?.length ? filters.machines.join(', ') : 'All Machines',
            'Departments Filter': filters.departments?.length ? filters.departments.join(', ') : 'All Departments',
            'Shifts Filter': filters.shifts?.length ? filters.shifts.join(', ') : 'All Shifts',
            'Metrics Filter': filters.metrics?.length ? filters.metrics.join(', ') : 'All Metrics',
            'Total Filters Applied': (filters.machines?.length || 0) + (filters.departments?.length || 0) + 
                                   (filters.shifts?.length || 0) + (filters.metrics?.length || 0)
          }
        },
        {
          title: 'Recommendations',
          type: 'text',
          description: 'AI-generated insights and recommendations based on filtered data',
          data: [
            '• Optimize carding stage to reduce bottleneck and improve overall throughput by 15%',
            '• Schedule preventive maintenance for Ginning Machine 2 within next 72 hours',
            '• Implement automated quality pre-screening to reduce manual inspection workload',
            '• Consider workforce reallocation during night shift to improve efficiency',
            '• Monitor machine utilization patterns for predictive maintenance scheduling',
            filters.machines?.length ? `• Focus on ${filters.machines.join(', ')} for targeted improvements` : '',
            filters.departments?.length ? `• Priority departments: ${filters.departments.join(', ')}` : '',
            '• Filtered data analysis shows specific areas requiring immediate attention'
          ].filter(Boolean) // Remove empty strings
        }
      ]
    };
  }

  // Helper methods
  private static addMetricsSection(doc: any, data: any, yPosition: number): number {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    Object.entries(data).forEach(([key, value]) => {
      doc.text(`${key}: ${value}`, 25, yPosition);
      yPosition += 6;
    });

    return yPosition + 5;
  }

  private static addTableSection(doc: jsPDFWithAutoTable, data: any, yPosition: number): number {
    if (data.headers && data.rows) {
      try {
        autoTable(doc, {
          head: [data.headers],
          body: data.rows,
          startY: yPosition,
          styles: { fontSize: 8 },
          headStyles: { fillColor: [79, 70, 229] },
          margin: { left: 20, right: 20 }
        });
        return (doc as any).lastAutoTable?.finalY ? (doc as any).lastAutoTable.finalY + 10 : yPosition + 50;
      } catch (error) {
        console.error('Error adding table:', error);
        // Fallback to simple text if autoTable fails
        doc.setFontSize(10);
        doc.text('Table data (autoTable not available)', 20, yPosition);
        return yPosition + 15;
      }
    }
    return yPosition;
  }

  private static addTextSection(doc: any, data: any, yPosition: number): number {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    if (Array.isArray(data)) {
      data.forEach(text => {
        doc.text(text, 25, yPosition);
        yPosition += 6;
      });
    } else {
      doc.text(data, 25, yPosition);
      yPosition += 6;
    }

    return yPosition + 5;
  }

  private static addChartSection(doc: any, data: any, yPosition: number): number {
    // For now, just add a placeholder
    doc.setFontSize(10);
    doc.text('Chart data visualization would be displayed here', 25, yPosition);
    return yPosition + 20;
  }

  private static convertSectionToSheetData(section: any): any[][] {
    const data: any[][] = [];
    data.push([section.title]);
    
    if (section.description) {
      data.push([section.description]);
    }
    data.push([]);

    if (section.type === 'metrics') {
      Object.entries(section.data).forEach(([key, value]) => {
        data.push([key, value]);
      });
    } else if (section.type === 'table' && section.data.headers && section.data.rows) {
      data.push(section.data.headers);
      section.data.rows.forEach((row: any) => {
        data.push(row);
      });
    }

    return data;
  }

  private static convertSectionToTableData(section: any): any[][] {
    const data: any[][] = [];

    if (section.type === 'metrics') {
      Object.entries(section.data).forEach(([key, value]) => {
        data.push([key, value]);
      });
    } else if (section.type === 'table' && section.data.headers && section.data.rows) {
      data.push(section.data.headers);
      section.data.rows.forEach((row: any) => {
        data.push(row);
      });
    }

    return data;
  }

  private static getTimeRangeLabel(timeRange: string): string {
    const labels: { [key: string]: string } = {
      '1d': 'Last 24 Hours',
      '7d': 'Last 7 Days',
      '30d': 'Last 30 Days',
      '90d': 'Last 90 Days',
      'custom': 'Custom Range'
    };
    return labels[timeRange] || 'Unknown Range';
  }
}

export default ExportService;
